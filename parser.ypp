%{


#include "output.hpp"
#include "source.hpp"

using namespace output;

int yylex();
void yyerror(char const * message);



// Global Variables:
	
	stack <SymbolTable*>* tables_stack = new stack <SymbolTable*>();
	stack <int>* offsets_stack = new stack <int>();

%}


%token VOID INT BYTE B BOOL AND OR TRUE FALSE RETURN IF WHILE BREAK CONTINUE PRECOND SC COMMA LPAREN RPAREN LBRACE RBRACE RELOP BINOP ID NUM STRING ASSIGN

/* Solving conflicts */
// Exp rules related conflicts
%left  OR //check if needs to be rigt assoc
%left AND //check if needs to be rigt assoc
%nonassoc RELOP
%nonassoc BINOP
%right NOT
// Dangling if else conflict
%nonassoc NO_ELSE
%nonassoc ELSE

%%

Program : M Funcs
{
	
}
;

M : %empty
{
	// global scope
		SymbolTable* table = new SymbolTable();
		tables_stack->push(table);
		offsets_stack->push(0);
}
;

LBrace: %empty
{
		
		SymbolTable* table = new SymbolTable();
		tables_stack->push(table);
		offsets_stack->push(offsets_stack->top());
}
;

RBrace: %empty
{
	endScope();
	
	SymbolTable* current = tables_stack->top();
	if (current) cout << "current pointer is not null" <<endl;
	cout << current->size();
	/*
	for (int i=0; i<current.size(); ++i)
	{
		SymbolTableEntry* entry = current[i];
		cout << "test1";
		if (entry)
		{
			cout << "test2";
			printID(entry->name, entry->offset, entry->type);
		}
	} 
	*/

	offsets_stack->pop();
	tables_stack->pop();
}
;

Funcs : %empty | FuncDecl Funcs
;

FuncDecl : RetType ID LPAREN Formals RPAREN PreConditions LBRACE LBrace Statements RBRACE RBrace 
;

RetType : Type | VOID
;

Formals : %empty | FormalsList
;

FormalsList : FormalDecl | FormalDecl COMMA FormalsList
;

FormalDecl : Type ID
;

PreConditions : %empty | PreConditions PreCondition
;

PreCondition : PRECOND LPAREN Exp RPAREN
;

Statements : Statement | Statements Statement
;

Statement : LBRACE LBrace Statements RBRACE RBrace | Type ID SC | Type ID ASSIGN Exp SC | ID ASSIGN Exp SC | Call SC | RETURN SC | RETURN Exp SC  | WHILE LPAREN Exp RPAREN Statement | BREAK SC | CONTINUE SC | SelectionStatement
;

SelectionStatement: IF LPAREN Exp RPAREN Statement %prec NO_ELSE | IF LPAREN Exp RPAREN Statement ELSE Statement

;

Call : ID LPAREN ExpList RPAREN | ID LPAREN RPAREN
;

ExpList : Exp | Exp COMMA ExpList

Type : INT | BYTE | BOOL
;

Exp : LPAREN Exp RPAREN | Exp BINOP Exp | ID | Call | NUM | NUM B | STRING | TRUE | FALSE | NOT Exp | Exp AND Exp | Exp OR Exp | Exp RELOP Exp
;

%%

void yyerror(const char * message)
{
	errorSyn(1); //TODO: put real error number
}


int main() {
	return yyparse();
}