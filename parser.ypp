%{

#include <iostream>
#include <vector>
#include <utility>
#include <stdlib.h>
#include "source.hpp"
#include "output.hpp"
#include "parser.hpp"

using namespace std;
using namespace Parser;
using namespace output;

extern int yylineno;
int yylex();
void yyerror(char const * message);

int precondCnt = 0;
int whileLoopCnt = 0;
string currentReturnType;

%}


%token VOID INT BYTE B BOOL AND OR TRUE FALSE RETURN IF WHILE BREAK CONTINUE PRECOND SC COMMA LPAREN RPAREN LBRACE RBRACE RELOP BINOP ID NUM STRING ASSIGN

/* Solving conflicts */
// Exp rules related conflicts
%right ASSIGN
%left  OR //check if needs to be rigt assoc
%left AND //check if needs to be rigt assoc
%nonassoc RELOP
%nonassoc BINOP
%right NOT
// Dangling if else conflict
%nonassoc NO_ELSE
%nonassoc ELSE

%%

Program : M Funcs
{
    if (!checkMainFuncLegal())
    {
        errorMainMissing();
        exit(0);
    }
    closeScope(); 
}
;

M : %empty
{
	endScope();
	openGlobalScope();

	// push print to global scope stack
	pushFunctionDeclarationWithoutOpenScope("VOID", "print");

	// push printi to global scope stack
	pushFunctionDeclarationWithoutOpenScope("VOID", "printi");
}
;

LBrace: %empty
{

	openScope();
}
;

RBrace: %empty
{
	closeScope();
}
;

Funcs : %empty | FuncDecl Funcs //DONE! no need to change
;

FuncDecl : RetType ID LPAREN Formals RPAREN PreConditions LBRACE
{
	// check if id is free
	NameTypeInfo* id = dynamic_cast<NameTypeInfo*>($2);
    string name = id->name;
	if (!checkIdFree(name))
	{
	    errorDef(yylineno,name);
	    exit(0);
	}

	// get parameters from input
	string retType = $1->type;
	MultiNameMultiTypeInfo* formals = dynamic_cast<MultiNameMultiTypeInfo*>($4);
	vector<pair<string, string> > args = formals->types_names;

	$$ = new FuncInfo(name,retType,args);

	// push function to global scope symbol table and open new scope for arguments
	pushFunctionDeclarationToStackAndOpenScope(retType, name, args);

} Statements RBRACE {
	NameTypeInfo* id = dynamic_cast<NameTypeInfo*>($2);
	string name = id->name;

	closeScope(true,name,precondCnt);
}
;

RetType : Type {$$ = $1; currentReturnType = $1->type;} | VOID {$$ = new Type("VOID"); currentReturnType = "VOID";}
;

Formals : %empty
{
	$$ = new MultiNameMultiTypeInfo();
}
| FormalsList
{
	$$ = $1;
}
;

FormalsList : FormalDecl
{
	NameTypeInfo* formalDec = dynamic_cast<NameTypeInfo*>($1);
	vector<pair<string,string> > v;
	v.push_back(pair<string,string>(formalDec->type, formalDec->name));

	$$ = new MultiNameMultiTypeInfo(v);
}
| FormalDecl COMMA FormalsList
{
	MultiNameMultiTypeInfo* formalList = dynamic_cast<MultiNameMultiTypeInfo*>($3);
	NameTypeInfo* formalDec = dynamic_cast<NameTypeInfo*>($1);
	vector<pair<string,string> > v(formalList->types_names);
	v.push_back(pair<string,string>(formalDec->type,formalDec->name));

	$$ = new MultiNameMultiTypeInfo(v);
}
;

FormalDecl : Type ID
{
	NameTypeInfo* id = dynamic_cast<NameTypeInfo*>($2);
	$$ = new NameTypeInfo($1->type, id->name);
}
;

PreConditions : %empty
{
	precondCnt = 0;
}
| PreConditions PreCondition
{
	precondCnt++;
}
;

PreCondition : PRECOND LPAREN Exp RPAREN
{
	if ($3->type!="BOOL") { // todo add function call
	    //errorMismatch(yylineno); exit(0);
	}
	$$ = $3;
}
;

Statements : Statement | Statements Statement //DONE! no need to change
;

Statement : LBRACE LBrace Statements RBRACE RBrace
| Type ID SC
{
	NameTypeInfo* id = dynamic_cast<NameTypeInfo*>($2);



	pushIdentifierToStack($1->type,id->name);
}
| Type ID ASSIGN Exp SC
{
	NameTypeInfo* id = dynamic_cast<NameTypeInfo*>($2);
    // check id is free
    if (!checkIdFree(name))
    {
        errorDef(yylineno,name);
        exit(0);
    }
	//todo: checkExpressionType($1->type,$4->type,yylineno);
	pushIdentifierToStack($1->type,id->name);
}
| ID ASSIGN Exp SC
{
	//todo: check for semantic errors, no need to push to stack
	NameTypeInfo* id = dynamic_cast<NameTypeInfo*>($1);

    // check id is free
    if (!checkIdFree(name))
    {
        errorDef(yylineno,name);
        exit(0);
    }

	//checkExpressionType($1->type,$3->type,yylineno);
	
}
| Call SC 
| RETURN SC 
{
	if (currentReturnType!="VOID")
	{
		errorMismatch(yylineno);
		exit(0);
	}
}
| RETURN Exp SC 
{
	if (currentReturnType!="INT" || currentReturnType != "BYTE" || currentReturnType!=$2->type)
	{
		errorMismatch(yylineno);
		exit(0);		
	}
}
| WHILE {whileLoopCnt++;} LPAREN Exp RPAREN Statement 
{
	whileLoopCnt--;
	if ($3->type!="BOOL")
	{
		errorMismatch(yylineno);
		exit(0);		
	}
}
| BREAK SC 
{
	if (whileLoopCnt == 0)
	{
		errorUnexpectedBreak(yylineno);
		exit(0);
	}
}
| CONTINUE SC 
{
	if (whileLoopCnt == 0)
	{
		errorUnexpectedContinue(yylineno);
		exit(0);
	}
}
| SelectionStatement
;

SelectionStatement: IF LPAREN Exp RPAREN Statement %prec NO_ELSE 
{
	//checkExpressionType($3->type,"BOOL",yylineno);
}
| IF LPAREN Exp RPAREN Statement ELSE Statement
{
	//checkExpressionType($3->type,"BOOL",yylineno);
}
;

Call : ID LPAREN ExpList RPAREN
{
	// check if id is undefined
    if (errorUndefFunc(name))
    {
        errorDef(yylineno,name);
        exit(0);
    }
    //todo: check prototype
}
| ID LPAREN RPAREN
{
	// check if id is undefined
    if (errorUndefFunc(name))
    {
        errorDef(yylineno,name);
        exit(0);
    }
    //todo: check prototype
}
;

ExpList : Exp
{
	$$ = new NameMultiTypeInfo($1->type);
}
| Exp COMMA ExpList
{
	NameMultiTypeInfo* expList = dynamic_cast<NameMultiTypeInfo*>($3);
	string type = $1->type;
	vector<string> types = expList->types;
	types.push_back(type);

	$$ = new NameMultiTypeInfo(types);
}
;

Type : INT {$$ = new Type("INT");} | BYTE {$$ = new Type("BYTE");} | BOOL {$$ = new Type("BOOL");}
;

Exp : LPAREN Exp RPAREN
{
	$$ = $2;
}
| Exp BINOP Exp
{
	//if ($1->type!="INT" && $1->type!="BYTE") {errorMismatch(yylineno); exit(0);}
	//if ($3->type!="INT" && $3->type!="BYTE") {errorMismatch(yylineno); exit(0);}
	NameTypeInfo* id = dynamic_cast<NameTypeInfo*>($2);
	string binOp = id->name;

	if (binOp == ">" || binOp == "<" || binOp == "==" || binOp == "!=")
	{
		$$ = new Type("BOOL");
	}
	else {
		if ($1->type == "INT") $$ = new Type("INT");
		else $$ = new Type("BYTE");
	}
}
| ID
{
	NameTypeInfo* id = dynamic_cast<NameTypeInfo*>($1);
	if (checkIdFree(id->name))
	{
	    errorUndef(yylineno,id->name);
	    exit(0);
	}
	string type = getIdType(id);
	$$ = new Type(type); //todo: check if this is a good idea
}
| Call
{
	$$ = $1;
}
| NUM
{
	$$ = $1;
}
| NUM B
{
	NameTypeInfo* numId = dynamic_cast<NameTypeInfo*>($1);
	int num = atoi(numId->name.c_str());

	if (num > 255)
	{
		errorByteTooLarge(yylineno,numId->name);
	}

	$$ = new Type("BYTE");
}
| STRING
{
	$$ = new Type("STRING");
}
| TRUE
{
	$$ = new Type("BOOL");
}
| FALSE
{
	$$ = new Type("BOOL");
}
| NOT Exp
{
	//checkExpressionType($2->type,"BOOL",yylineno);
	$$ = new Type("BOOL");
}
| Exp AND Exp
{
	//checkExpressionType($1->type,"BOOL",yylineno);
	//checkExpressionType($3->type,"BOOL",yylineno);
	$$ = new Type("BOOL");
}
| Exp OR Exp
{
	//checkExpressionType($1->type,"BOOL",yylineno);
	//checkExpressionType($3->type,"BOOL",yylineno);
	$$ = new Type("BOOL");
}
| Exp RELOP Exp
{
 	//if ($1->type!="INT" && $1->type!="BYTE") {errorMismatch(yylineno); exit(0);}
	//if ($3->type!="INT" && $3->type!="BYTE") {errorMismatch(yylineno); exit(0);}
	$$ = new Type("BOOL");
}
;

%%

void yyerror(const char * message)
{
	errorSyn(yylineno); 
}


int main() {
	yyparse();
}